# 03 아키텍처
## MySQL 아키텍처
MySQL 아키텍처는 다른 DBMS에 비해 구조가 독특하다. 이러한 구조로 얻는 이점도 있지만 다른 DBMS에서는 발생하지 않는 문제점이 있기도 하다.

<그림 3-1>

MySQL 서버는 크게 MySQL 엔진과 스토리지 엔진으로 구분한다.
- MySQL 엔진: 쿼리 파서, 옵티마이저 등
- 스토리지 엔진
MySQL 엔진은 이 책에서 위처럼 스토리지 엔진과 구분하고자 만들었고, 이 둘을 합쳐 MySQL 서버라고 표현한다.

#### MySQL 엔진
요청된 SQL 문장을 분석하거나 최적화
- SQL 관련
    - 커넥션 핸들러: 클라이언트로부터 접속 및 쿼리 요청 처리
    - SQL 파서 및 전처리기
    - 옵티마이저: 쿼리 최적화
- 성능 향상(보조 저장소)
    - MyISAM 키 캐시
    - InnoDB 버퍼 풀
- 표준 SQL 문법 지원

#### 스토리지 엔진
실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 작업
- MySQL 엔진은 하나이지만, 스토리지 엔진은 여러 개를 동시에 사용 가능

```sql
CREATE TABLE test_table (fd1 INT, fd2 INT) ENGINE=INNODB;
```

위 명령어로 해당 테이블은 InnoDB를 사용하도록 설정할 수 있다.

#### 핸들러 API
MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 각 스토리지 엔진에 쓰기 또는 읽기 요청을 해야 하는데, 이를 핸들러 요청이라 한다.
- 핸들러 API를 통해 데이터 작업량 확인

```sql
SHOW GLOBAL STATUS LIKE 'Handler%';
```

### MySQL 스레딩 구조
MySQL 서버는 프로세스 기반이 아닌 스레드 기반으로 동작한다.

<그림 3-2>

#### 포그라운드(Foreground) 스레드(클라이언트 스레드)
포그라운드 스레드는 최소한 MySQL 서버에 접속된 클라이언트의 수만큼 존재한다. 이 스레드는 주로 각 클라이언트가 요청한 쿼리 문장을 처리한다. 클라이언트가 작업을 마치고 커넥션을 종료하면, 해당 커넥션을 담당하던 스레드는 다시 스레드 캐시로 되돌아간다.
- 스레드 캐시(Thread Pool)
    - 일정 개수 이상의 대기중인 스레드가 존재한다.
    - 위 개수가 유지되면 종료된 커넥션 스레드는 캐시에 넣지 않고 종료시킨다.
    - 일정 개수는 파라미터 `thread_cache_size`로 관리한다.

포그라운드 스레드는 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져오며, 이에 없는 경우 직접 디스크나 인덱스 파일로부터 읽어온다.
- MyISAM: 디스크 쓰기 작업까지 포그라운드 스레드가 처리
- InnoDB: 데이터 버퍼나 캐시까지 포그라운드 스레드, 나머지 버퍼 ~ 디스크는 백그라운드 스레드가 처리

#### 백그라운드(Background) 스레드
InnoDB는 여러 가지 작업을 백그라운드 스레드로 처리한다. 이 스레드가 처리하는 것은 다음과 같다.
- Insert Buffer를 병합
- **로그를 디스크로 기록**
- **InnoDB 버퍼 풀의 데이터를 디스크에 기록**
- 데이터를 버퍼로 읽음
- 여러 잠금이나 데드락 모니터링
- 위 작업을 총괄하는 메인 스레드

InnoDB에서는 쓰기 스레드가 많은 작업을 백그라운드로 처리한다.

---

SQL 처리 도중 데이터의 쓰기 작업은 지연 처리가 가능하지만, 읽기 작업은 절대 지연 처리를 하지 않는다. 따라서 일반적인 DBMS에는 대부분 쓰기 작업을 버퍼링해서 일괄 처리한다.(InnoDB도 마찬가지) 하지만 MyISAM은 지연 처리 기능이 없다.

지연 처리의 장점은 `INSERT, UPDATE, DELETE`와 같은 쿼리로 데이터의 변경이 일어날 때 데이터가 디스크의 데이터 파일로 완전히 저장될 때까지 기다리지 않아도 된다.


### 메모리 할당 및 사용 구조

<그림 3-3>

#### 글로벌 메모리 영역
- MySQL 서버가 시작되면서 무조건 운영체제로부터 메모리 공간이 할당된다.
- 클라이언트 스레드의 수와 무관하게 일반적으로 하나의 메모리 공간만 할당된다.

#### 로컬 메모리 영역
- 세션 메모리 영역이라고도 함
- MySQL 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역
- 각 클라이언트 스레드별로 독립적으로 할당되며 절대 공유되지 않음
- 필요하지 않으면 할당조차 안될 수도 있다.(ex 소트 버퍼, 조인 버퍼)


### 플러그인 스토리지 엔진 모델
MySQL의 독특한 구조 중 대표적으로 플러그인 모델이 있다. MySQL은 여러 스토리지 엔진이 존재하는데, MyISAM과 InnoDB 외에는 대부분 플러그인으로 제공된다.

MySQL에서 쿼리를 처리하는 과정은 대부분이 MySQL 엔진에서 처리되고, 마지막 '데이터 읽기/쓰기' 작업만 스토리지 엔진에 의해 처리된다. 여기서 **핸들러(Handler)**라는 표현이 자주 사용되는데, 이는 MySQL 엔진이 스토리지 엔진을 사용할 때 핸들러를 호출한다.(실제 MySQL 코드에서 'Handler'라는 이름으로 사용됨)

중요한 점은 **하나의 쿼리 작업은 여러 하위 작업으로 나뉘는데, 각 하위 작업이 MySQL 엔진 영역에서 처리되는지 아니면 스토리지 엔진 영역에서 처리되는지 구분할 줄 알아야한다.**

플러그인 형태로 제공되는 모든 기능은 손쉽게 적용할 수 있다. 모든 플러그인의 내용은 다음 명령어로 확인할 수 있다.

```sql
SHOW PLUGINS;
```


### 쿼리 실행 구조

<그림 3-6>

#### 파서
파서는 쿼리 문장을 토큰(MySQL이 인식할 수 있는 최소 단위의 어휘나 기호)으로 분리해 트리 형태의 구조로 만든다. 쿼리 문장의 기본 문법 오류는 이 과정에서 발견되며 이를 사용자에게 오류 메시지로 전달한다.

#### 전처리기
파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인한다. 각 토큰을 테이블 이름이나 칼럼 이름 또는 내장 함수와 같은 개체로 매핑하여 객체의 존재 여부와 객체의 접근권한 등을 확인한다. 실제 존재하지 않거나 권한상 사용할 수 없는 개체의 토큰을 거른다.

#### 옵티마이저
옵티마이저는 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지 결정하는 역할을 한다. 이는 DBMS의 두뇌에 해당한다. 옵티마이저의 역할은 DBMS에서 매우 중요한 역할을 한다.

#### 실행 엔진
옵티마이저가 두뇌라면 실행 엔진과 핸들러는 손과 발이다. 회사로 비유하면
- 옵티마이저 -> 경영진
- 실행 엔진 -> 중간 관리자
- 핸들러 -> 실무자

옵티마이저가 GROUP BY를 처리하기 위해 임시 테이블을 사용하는 예제를 통해 실행 엔진의 역할을 살펴보자.
1. 실행 엔진은 핸들러에게 임시 테이블을 만들라고 요청
2. 다시 실행 엔진은 WHERE 절에 일치하는 레코드를 읽어오라고 핸들러에게 요청
3. 읽어온 레코드들을 1번에서 준비한 임시 테이블로 저장하라고 다시 핸들러에게 요청
4. 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어 오라고 핸들러에게 다시 요청
5. 최종적으로 실행 엔진은 결과를 사용자나 다른 모듈로 넘김

실행 엔진은 각 핸들러에게 작업을 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행한다.

#### 핸들러(스토리지 엔진)
핸들러는 MySQL 서버의 가장 밑단에서 실행 엔진의 요청에 따라 데이터를 디스크로 저장하거나 읽어오는 역할을 한다. 핸들러는 결국 스토리지 엔진을 말하며, MyISAM 테이블을 조작하는 경우는 핸들러가 MyISAM 스토리지 엔진이고 InnoDB 테이블을 조작하는 경우는 핸들러가 InnoDB 스토리지 엔진이다.


### 복제(Replication)

<그림 3-7>

MySQL의 복제는 레플리케이션이라고도 하며, **복제는 2대 이상의 MySQL 서버가 동일한 데이터를 담도록 실시간으로 동기화하는 기술이다.** MySQL 복제는 일반적으로 다음과 같이 두 가지로 나뉜다.
- `INSERT`나 `UPDATE와` 같은 쿼리를 이용해 데이터를 변경할 수 있는 MySQL 서버(쓰기용 MySQL 서버 - 마스터(Master))
- `SELECT` 쿼리로 테이블을 읽기만 할 수 있는 MySQL 서버(읽기용 MySQL 서버 - 슬레이브(Slave))

MySQL에서는 명칭을 위와 같이 쓰며, DBMS마다 명칭은 다를 수 있다. 일반적으로 마스터는 반드시 1개이며, 슬레이브는 1개 이상으로 구성한다.

마스터와 슬레이브는 역할을 지정한 것일 뿐 전용 MySQL 서버가 따로 존재하는 것은 아니다. 그리고 마스터에서 슬레이브 역할을 동시에 수행하기도 한다.

#### 마스터(Master)
기술적으로는 MySQL의 바이너리 로그가 활성화되면 어떤 MySQL 서버든 마스터가 될 수 있다. 
- 애플리케이션의 입장에서 마스터는 데이터가 생성, 변경, 삭제되는 주체(시작점)이다. 
- 데이터의 일관성을 위해 변경이 일어나는 마스터는 1개로 한정한다.
- 마스터 서버에서 실행되는 DML(데이터를 조작하는 문장)과 DDL(스키마를 변경하는 문장) 가운데 데이터의 구조나 내용을 변경하는 모든 쿼리는 바이너리 로그에 저장된다.
- 슬레이브 서버에서 변경 내역을 요청하면 마스터 서버는 그 바이너리 로그를 읽어 전달한다.
    - 마스터 서버의 프로세스 가운데 "Binlog dump" 스레드가 이를 전담한다.(슬레이브가 10개면, Binlog dump 스레드도 10개이다.)

#### 슬레이브(Slave)
데이터(바이너리 로그)를 받아 올 마스터 서버의 정보(IP, Port, 계정)를 가지고 있는 경우 슬레이브가 된다.
- 슬레이브 서버는 릴레이 로그를 가지고 있다. 
- 일반적으로 마스터와 슬레이브의 데이터 동일성을 위해 슬레이브는 읽기 전용이다.
- 슬레이브 서버의 I/O 스레드는 마스터 서버에 접속해 변경 내역을 요청하고, 받은 내용을 릴레이 로그에 기록한다.
- 슬레이브 서버의 SQL 스레드는 릴레이 로그에 기록된 변경 내역을 재실행(Replay)하여 마스터와 동일한 상태로 유지한다.
- I/O 스레드(Slave_IO_Thead)와 SQL 스레드(Slave_SQL_Thread)는 마스터가 아닌 슬레이브 서버에서 자동으로 동작한다.

#### 복제 시 주의할 점
- 슬레이브는 하나의 마스터만 설정 가능
    - 하나의 마스터에 N개의 슬레이브가 일반적인 형태(그 외 링, 트리 형태 등이 있음)
- 마스터와 슬레이브의 데이터 동기화를 위해 슬레이브는 읽기 전용으로 설정
    - 사용자의 실수로 데이터 변경을 슬레이브 서버에서 수행하는 경우가 있다. 이를 막기 위해 슬레이브 서버는 읽기 전용(read_only 파라미터 설정)으로 설정한다.
- 슬레이브 서버용 장비는 마스터와 동일한 사양이 적합
    - 마스터 서버에서 수많은 동시 사용자가 실행한 데이터 변경 쿼리 문장이 슬레이브 서버에서는 하나의 스레드로 모두 처리돼야 한다.(현재 구조상 어쩔 수 없음)
    - 변경이 많을 수록 마스터보다 슬레이브 사양이 더 좋아야 한다.
        - 그래야 마스터에서 동시에 여러 개의 스레드가 처리하는 것을 슬레이브가 하나의 스레드로 처리할 수 있음
        - 일반적으로 변경보다 조회가 10배 많으므로 슬레이브와 마스터 사양을 맞추는게 적합
    - 슬레이브 서버는 마스터 서버가 다운된 경우 그에 대한 복구 대안으로 사용하기도 한다.
- 복제가 불필요한 경우에는 바이너리 로그 중지
    - 바이너리 로그를 작성하는 것은 비용이 크다.
        - 로그를 안정적으로 기록하기 위해 갭 락(Gap lock)을 유지하고,
        - 매번 트랜잭션이 커밋될 대마다 데이터를 변경시킨 쿼리 문장을 기록한다.
    - 바이너리 로그를 기록하는 작업은 AutoCommit이 활성화된 상태에서 더 심각한 부하를 초래한다.
        - 특히 MyISAM은 트랜잭션을 지원하지 않아 AutoCommit 모드로 작동된다.
- 바이너리 로그와 트랜잭션 격리 수준(Isolation level)
    - 바이너리 로그 파일은 내용에 따라 두 가지 포맷 방식으로 나뉜다.
        - STATEMENT 포맷 방식: 마스터에서 실행되는 쿼리 문장
        - ROW 포맷 방식: 마스터에서 실행된 쿼리에 의해 변경된 레코드 값
    - 격리 수준에 따라 InnoDB 엔진에서 사용하는 락 갯수가 달라진다.


### 쿼리 캐시(Query Cache)
쿼리 캐시는 다른 DBMS에는 없는 MySQL의 독특한 기능 중 하나이다. 적절히 설정해두면 높은 성능 향상을 얻을 수 있다. 쿼리 캐시는 쿼리의 결과를 메로리에 캐시해둔다. 구조는 간단히 키와 값의 쌍으로 관리되는 맵(Map) 형태의 데이터 구조이다. 여기서 키는 쿼리 문장이고, 값은 해당 쿼리 문장의 결과이다.

단순히 쿼리 문장이 일치한다고 해서 캐시된 결과를 반환하면 안된다. 쿼리 처리는 매우 복잡한 절차를 거치기 때문에 캐시를 사용하기 위해서는 아래의 확인 절차가 필요하다.
#### 1. 요청된 쿼리 문장이 쿼리 캐시에 존재하는가?
- 쿼리를 비교할 때 공백, 탭, 대소문자까지 완벽히 동일해야 같은 쿼리로 인식한다.

#### 2. 해당 사용자가 그 결과를 볼 수 있는 권한을 가지고 있는가?

#### 3. 트랜잭션 내에서 실행된 쿼리인 경우, 그 결과가 가시 범위 내의 트랜잭션에서 만들어진 결과인가?(InnoDB인 경우)
- InnoDB의 모든 트랜잭션은 각 트랜잭션 ID를 갖는다. 트랜잭션 ID는 트랜잭션이 시작된 시점을 기준으로 순차적으로 증가하므로 자신의 ID보다 큰 값의 트랜잭션에서 변경한 작업 내역이나 쿼리 결과는 참조할 수 없다.

#### 4. 쿼리에 사용된 기능(내장 함수나 저장 함수 등)이 캐시돼도 동일한 결과를 보장할 수 있는가?
4.1 CURRENT_DATE, SYSDATE, RAND 등과 같이 호출 시점에 따라 결과가 달라지는 요소가 있는가?
- 이 함수들은 호출한 시간에 따라 결과가 달라지므로 캐시한 의미가 없다.

4.2 프리페어 스테이트먼트의 경우 변수가 결과에 영향을 미치지 않는가?
- 프리페어 스테이트먼트는 바인드 변수가 사용된 쿼리이므로 이를 통해 쿼리 캐시를 찾을 수 없다.
- 5.1 버전 이후부터는 가능하도록 변경됨

#### 5. 캐시가 만들어지고 난 이후 해당 데이터가 다른 사용자에 의해 변경되지 않았는가?
- 쿼리 캐시로 저장된 후 결과값이 변경되면 캐시한 값이 의미가 없어지므로 무효화해야한다.
- 쿼리 캐시는 여러 스레드에서 동시에 변경할 수 없다.
- 캐시 크기는 일반적으로 32MB ~ 64MB가 적당하다.

> 게시글 조회 기능은 SELECT 전에 UPDATE를 수행하므로 캐시된 값이 변경되어 결과값이 삭제되는 경우가 있다. 이는 쿼리 순서가 변경되도 마찬가지이다. 이를 해결하는 방법은 조회수 칼럼을 다른 테이블로 분리하거나 조회수를 일정한 횟수만큼 누적한 후 한꺼번에 업데이트한다.(후자 추천)

#### 6. 쿼리에 의해 만들어진 결과가 캐시하기에 너무 크지 않는가?
- 결과 크기에 따라 캐시로 저장할지를 선택할 수 있는 옵션이 존재한다.
- 결과의 크기가 적을수록 쿼리 캐시 효율이 증가한다.
    - 집합 함수의 결과가 쿼리 캐시로 사용하기 적합

#### 7. 그 밖에 쿼리 캐시를 사용하지 못하게 만드는 요소가 사용됐는가?
- 임시 테이블에 대한 쿼리
- 사용자 변수 사용
- 칼럼 기반의 권한 설정
- LOCK IN SHARE MODE 힌트
- FOR UPDATE 힌트
- UDF(User Defined Function) 사용
- 독립적인 SELECT 문장이 아닌 일부분의 서브 쿼리
- 스토어드 루틴(Procedure, Function, Trigger)에서 사용된 쿼리
- SQL_NO_CACHE 힌트

이렇게 캐시를 사용하지 못하는 수많은 제약이 존재하지만 이를 감수하더라도 쿼리 캐시의 효과를 충분히 얻을 수 있으므로 훌륭한 기능이다. 쿼리 캐시가 얼마나 사용됐고 하는지의 정보는 아래의 명령어를 통해 확인할 수 있다.

```sql
SHOW GLOBAL STATUS LIKE 'Qcache%';
```


## 3.2 InnoDB 스토리지 엔진 아키텍처
InnoDB는 MySQL 스토리지 엔진 중 가장 많이 사용되며, 거의 유일하게 레코드 기반의 잠금을 제공한다. 그리고 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.

### InnoDB 스토리지 엔진의 특성
#### 프라이머리 키에 의한 클러스터링
InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장된다. 이는 프라이머리 키 값의 순서대로 디스크에 저장된다는 의미이며, 그 결과 프라이머리 키에 의한 레인지 스캔은 상당히 빨리 처리될 수 있다. 쿼리의 실행 계획에서 프라이머리 키는 기본적으로 다른 보조 인덱스에 비해 비중이 높게 설정된다. (다른 보조 인덱스보다 프라이머리 키가 선택될 확률이 높다는 의미)

#### 잠금이 필요 없는 일관된 읽기(Non-locking consistent read)
InnoDB 스토리지 엔진은 MVCC(Multi Version Concurrency Control)라는 기술을 이용해 락을 걸지 않고 읽기 작업을 수행한다.

#### 외래 키 지원
외래 키에 대한 지원은 InnoDB 스토리지 엔진 레벨에서 지원하는 기능으로 MyISAM이나 MEMORY 테이블에서는 사용할 수 없다.

#### 자동 데드락 감지
InnoDB는 그래프 기반의 데드락 체크 방식을 사용하기 때문에 데드락이 발생함과 동시에 바로 감지되고, 감지된 데드락은 관련 트랜잭션 중에서 ROLLBACK이 가장 용이한 트랜잭션을 자동으로 강제 종료해 버린다.
- ROLLBACK이 가장 용이한 트랜잭션 = ROLLBACK 했을 때 복구 작업이 가장 작은 트랜잭션 = 레코드를 가장 적게 변경한 트랜잭션

#### 자동화된 장애 복구
InnoDB에는 솔실이나 장애로부터 데이터를 보호하기 위한 여러 가지 메커니즘이 탑재돼 있다.

#### 오라클의 아키텍처 적용
InnoDB 스토리지 엔진의 기능은 오라클 DBMS의 기능과 상당히 비슷한 부분이 많다.
- MVCC
- 언두(Undo)데이터가 시스템 테이블 스페이스에 관리됨
- 테이블 스페이스의 개념
- ...


### InnoDB 버퍼 풀
InnoDB 스토리지 엔진에서 가장 핵심적인 부분으로, 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간이다.(MyISAM은 인덱스 캐시만 함)
- 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할
- INSERT, UPDATE, DELETE 와 같은 데이터를 변경하는 쿼리를 모아서 처리하여 랜덤한 디스크 작업의 횟수를 줄임
- InnoDB 버퍼 풀 크기는 전체 물리 메모리의 50~80% 크기로 설정한다.(이는 일반적인 수치이며, 신중하게 설정해야 함)


### 언두(Undo) 로그
언두 영역은 UPDATE나 DELETE와 같은 문장으로 데이터를 변경했을 때 변경되기 전의 데이터를 보관하는 곳이다.

```sql
UPDATE member SET name='홍길동' WHERE member_id='1';
```

위 문장을 실행하면
- 트랜잭션을 커밋하지 않아도 실제 데이터 파일(데이터/인덱스 버퍼) 내용은 "홍길동"으로 변경된다.
- 변경되기 전의 값이 "벽계수"였다면, 언두 영역에는 "벽계수"라는 값이 백업된다.
- 만약 사용자가 커밋하게 되면 현재 상태가 그대로 유지되고
- 롤백하게 되면 언두 영역의 백업된 데이터를 다시 데이터파일로 복구한다.

언두 영역의 역할 크게 두 가지이다.
- 트랜잭션의 롤백 대비용(위 예제)
- 트랜잭션의 격리 수준을 유지하면서 높은 동시성을 제공

> 트랜잭션 격리 수준: 여러 트랜잭션이 데이터를 변경하거나 조회할 때, 한 트랜잭션의 작업 내용이 어떻게 보여질지를 결정하는 기준


### 인서트 버퍼(Insert Buffer)
인서트 버퍼는 인덱스를 업데이트할 때 성능 향상을 위한 임시 메모리 공간을 말한다. 인덱스를 업데이트하는 작업은 랜덤하게 디스크를 읽는 작업이 필요하므로 테이블에 인덱스가 많다면 많은 비용이 든다.


### 리두(Redo) 로그 및 로그 버퍼
쿼리 문장으로 데이터를 변경하고 커밋하면 DBMS는 데이터의 ACID를 보장하기 위해 즉시 변경된 데이터의 내용을 데이터 파일로 기록해야 한다. 하지만 이러한 데이터 파일의 변경 작업은 순차적으로 많은 데이터를 한꺼번에 변경하는 것이 아닌 랜덤하게 디스크에 기록해야 하므로 디스크를 상당히 바쁘게 한다. 이러한 부하를 줄이기 위해 대부분의 DBMS에는 변경된 데이터를 버퍼링해 두기 위해 InnoDB 버퍼 풀과 같은 장치가 있다. 하지만 이 장치만으로는 ACID를 보장할 수 없어 변경된 내용을 순차적으로 디스크에 기록하는 로그 파일을 가지고 있다. 이러한 로그를 리두 로그라고 하며, 일반적으로 DBMS에서 로그라 하면 리두 로그를 말한다.

- MySQL 서버 자체가 사용하는 로그 파일은 편집기로 열어볼 수 없으며, 볼 필요도 없다.
- 리두 로그 덕분에 DBMS 데이터는 버퍼링을 통해 한꺼번에 디스크에 변경된 내용을 처리할 수 있다.
- 사용량(특히 변경 작업)이 매우 많은 DBMS 서버의 경우에는 이 리두 로그의 기록 작업의 부하가 문제가 된다.
    - 이를 보완하기 위해 최대한 ACID 속성을 보장하는 수준으로 버퍼링한다.
- 리두 로그 버퍼링에 사용되는 공간이 로그 버퍼이다.
    - 로그 버퍼의 크기는 일반적으로 1~8MB 수준이며, BLOB이나 TEXT와 같은 큰 데이터를 자주 변경하는 경우는 더 크게 설정한다.


### MVCC(Multi Version Concurrency Control)
MVCC는 일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이며, MVCC의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는데 있다.
- InnoDB는 언두 로그를 이용해 이 기능을 구현한다.
- 멀티 버전은 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 의미이다.

이는 UPDATE문과 같은 데이터 변경 쿼리가 수행되고 커밋이나 롤백이 되기 전에 해당 데이터에 접근할 때 여러 격리 수준(Isolation level)이 존재한다. 격리 수준에 따라 InnoDB 버퍼 풀이나 데이터 파일을 읽기도 하고, 언두 영역을 읽기도 한다.

> 트랜잭션이 길어지면 언두 영역에서 관리 되는 데이터가 무한히 커질 수도 있다.

UPDATE문 쿼리 후 커밋이 되면 해당 데이터를 영구적으로 만들고, 롤백을 하면 언두 영역에 있는 데이터를 InnoDB 버퍼 풀로 복구하고, 언두 내용을 삭제한다. 커멧 후에는 더이상 언두 영역을 필요로하는 트랜잭션이 없을 때 언두 영역 데이터를 삭제한다.


### 잠금 없는 일관된 읽기
InnoDB는 SELECT 쿼리를 처리할 때 어떠한 방해도 받지 않는다. 만약 UPDATE를 실행중인 데이터를 읽을 때도 해당 데이터가 락이 걸려있지만, SELECT 쿼리를 수행할 때는 락이 걸려있는 데이터의 언두 영역의 데이터를 읽으므로, 방해를 받지않고 바로 읽을 수 있다.

트랜잭션이 오랫동안 지속되면 느려지거나 문제가 발생하는 경우가 있는데, 이는 일관된 읽기를 위한 언두 로그를 삭제하지 못하고 계속 유지해야하기 때문이다. 트랜잭션은 가능한 빨리 커밋이나 롤백으로 완료해야 한다.


### InnoDB와 MyISAM 스토리지 엔진 비교
InnoDB는 거의 모든 면에서 MyISAM보다 성능면에서 뛰어나다. 이는 여러 테스트로 증명되어 있다. InnoDB의 한가지 단점은 MyISAM보다 설정이 까다롭다는 것이다.


### InnoDB와 MEMORY(HEAP) 스토리지 엔진 비교
MEMORY 스토리지 엔진의 가장 큰 장점은 데이터와 인덱스를 모두 메모리에 저장하기 때문에 저장이나 읽기 작업이 매우 빠르다는 것이다. 하지만 이를 동시성이 높은 것은 아니다. 
- MEMORY 스토리지 엔진은 테이블 수준의 잠금
- InnoDB 스토리지 엔진은 레코드 수준의 잠금

테이블 수준의 잠금의 문제점은 동시에 두 개 이상의 클라이언트가 테이블을 변경할 수 없다는 것이다.

MEMORY 테이블은 여러 커넥션에 의해 읽기 위주로 사용되는 경우 또는 단일 커넥션으로 사용될 때 적합하다.


## MyISAM 스토리지 엔진 아키텍처

### 키 캐시(Key Cache)
InnoDB 버퍼 풀과 비슷한 역할을 하는 것이 MyISAM의 키 캐시(키 버퍼)이다. 키 캐시는 인덱스만 대상으로 작동하며 인덱스의 디스크 쓰기 작업에 대해서만 부분적으로 버퍼링 역할을 한다.

### 운영체제의 캐시 및 버퍼
MyISAM 테이블의 인덱스는 키 캐시를 이용해 디스크를 검색하지 않고도 충분히 빠르게 검색가능하다. 하지만 테이블의 데이터는 디스크로부터 I/O를 해결해 줄 만한 어떠한 캐시나 버퍼링 기능이 없다. 그래서 MyISAM 테이블의 데이터 읽기나 쓰기 작업은 항상 운영체제의 디스크 읽기 또는 쓰기 작업으로 요청한다.
- 운영체제는 디스크로부터 읽고 쓰는 파일에 대한 캐시나 버퍼링 메커니즘을 가지고 있으므로 MySQL 서버가 요청하는 디스크 읽기 작업이 매번 디스크 파일을 읽지는 않는다.
- 운영체제는 InnoDB와 같은 데이터에 대한 전문적인 캐시나 버퍼링을 하지는 못한다.


## MEMORY 스토리지 엔진 아키텍처
MEMORY 스토리지 엔진은 HEAP 스토리지 엔진이라고도 하며, 데이터를 메모리에 저장하는 것이 특징이다. MEMORY 스토리지 엔진은 데이터의 크기가 작고 아주 빠른처리가 필요한 경우에 적합하다.

### 주의사항
#### 테이블의 최대 크기
- MEMORY 스토리지 엔진은 다른 스토리지 엔진과 달리 테이블의 최대 크기가 정해져있다.
- max_heap_table_size 파라미터로 정의할 수 있다.

#### 고정 길이 칼럼만 지원
- BLOB, TEXT, LOB와 같은 대용량 칼럼은 사용할 수 없다.

#### MEMORY 테이블은 기본적으로 해시 인덱스 사용
- InnoDB와 MyISAM은 기본적으로 B-Tree 인덱스를 사용하지만 MEMORY 스토리지 엔진은 해시 인덱스를 사용한다.

### MEMORY 스토리지 엔진의 용도
MEMORY 스토리지 엔진은 사용자가 명시적으로 사용할 수도 있지만, MySQL에서는 대부분 임시 테이블 용도로 사용한다. 임시 테이블은 MySQL 엔진이 쿼리를 처리하는 과정에서 임시로 생성하는 테이블로, 해당 커넥션에서만 유효하다.


## NDB 클러스터 스토리지 엔진
NDB 클러스터는 Network DataBase의 줄임말로 네트워크를 통해 데이터 분산을 지원하는 스토리지 엔진이다. 이는 다른 스토리지 엔진과 작동 방식과 용도가 많이 다르다.

### NDB 클러스터의 특성
NDB 클러스터 스토리지 엔진은 용도가 명확한 편이다.
- 무공유(Shared-nothing) 클러스터링
- 메모리 기반의 스토리지 엔진
- 자동화된 페일 오버(Fail-over)
- 분산된 데이터 저장소간의 동기 방식(Sync) 복제
- 온라인 스키마 변경
- NoSQL(MySQL과의 독립성)
- 네트워크 DB

### NDB 클러스터의 용도
회원의 로그인 정보 즉 세션 정보를 관리하는 세션 전용 데이터베이스로 사용된다. 회원의 수는 정해져있어 저장 공간이 고정적이다. 이러한 특성으로 NDB 클러스터 스토리지 엔진이 적합하다.


## TOKUDB 스토리지 엔진
TOKUDB 스토리지 엔진은 최근에 만들어졌으며, 크게 주목받는 스토리지 엔진은 아니다. 하지만 기존의 인덱스를 처리하는 방식인 B-Tree의 단점을 보완한 것에서 살펴볼 가치가 있다.

### 프랙탈 트리(Fractal Tree) 인덱스 지원
기존 B-Tree는 새로운 인덱스 값을 저장하려면 상대적으로 많은 비용이 든다. 상당한 랜덤 읽기와 쓰기 작업이 필요하며, 인덱스의 데이터 단편화로 많은 공간이 쓰이지 않는다. 그래서 범위 검색을 할 때 더 많은 범위를 읽어야 하는 문제점이 발생한다.

프랙탈 트리는 이를 보완한 것으로 대용량 데이터와 빠른 INSERT 처리가 가능하다. 하지만 아직까지 트랜잭션 및 잠금 처리 부분에서 안정성이 기존의 스토리지 엔진에 비해 많이 부족하다.

### TokuDB의 주 용도
TojuDB의 용도는 매우 명확하다. 빠르게 증가하는 대용량 데이터를 관리하는 것이 특기이다. 대표적인 예는 다음과 같다.
- SNS 기반의 대용량 테이블(동시성이 크게 요하지 않는)
- 실시간 웹페이지 클릭 분석
- 웹 서버나 게임 서버의 로그 분석
- 고성능 웹 크롤링
- 데이터웨어 하우스


## MySQL 로그 파일
MySQL의 문제점을 분석하기 위해서는 로그 파일 내용을 보는 것이 가장 중요하다.(다른 사용 DBMS에 비해 진단 도구가 부족하기도 하다.)

### 에러 로그 파일
에러 로그 파일은 MySQL이 실행되는 도중에 발생하는 에러나 경고 메시지가 출력되는 로그 파일이다. 에러 로그 파일의 위치는 "log_error" 파라미터에 정의된 경로나 ".err" 확장자가 붙은 파일이다.

#### MySQL이 시작되는 과정과 관련된 정보성 및 에러 메시지
MySQL 설정 파일을 변경하거나 데이터베이스가 비정상적으로 종료된 후 다시 시작할 때는 반드시 MySQL 에러 로그 파일을 확인한다.
- 설정된 변수의 이름이나 값이 명확하게 설정되고 의도한대로 적용되었는지 확인
- MySQL 서버가 정상적으로 동작했는지 확인("mysqlId started" 메시지 확인)
- 특정 변수가 무시됐는지 확인
- 변수명이나 설정된 파라미터 값의 내용이 인식되었는지 확인

#### 마지막으로 종료할 때 비정상적으로 종료된 경우 나타나는 InnoDB의 트랜잭션 복구 메시지
InnoDB의 경우 MySQL 서버가 비정상적 또는 강제적으로 종료됐다면 다시 시작하면서 완료되지 못한 트랜잭션을 정리하고 디스크에 기록되지 못한 데이터가 있다면 다시 기록하는 재처리 작업을 한다. 이 과정에 대한 간단한 메시지가 출력되며, 문제가 있다면 에러 메시지를 출력하고 MySQL은 다시 종료된다.

#### 쿼리 처리 도중에 발생하는 문제에 대한 에러 메시지
쿼리 도중 발생하는 문제점은 사전 예방이 어려우며, 주기적으로 에러 로그 파일을 검토하는 과정에서 알게 된다.
- 쿼리 실행 도중 에러 메시지
- 복제에서 문제가 될 만한 쿼리에 대한 경고 메시지

#### 비정상적으로 종료된 커넥션 메시지(Aborted connection)
클라이언트 애플리케이션에서 정상적으로 접속 종료를 하지 못하고 프로그램이 종료된 경우, MySQL 서버의 에러 로그 파일에 이런 내용이 쌓인다.

#### InnoDB의 모니터링 명령이나 상태 조회 명령("SHOW ENGINE INNODB STATUS" 같은)의 결과 메시지
InnoDB의 테이블 모니터링, 락 모니터링, InnoDB 엔진 상태를 조회하는 명령은 에러 로그 파일에 기록된다. 이는 상당히 크기가 큰 메시지라 모니터링을 활성화하고 그대로 유지하는 경우 공간을 모두 사용할수도 있다. 반드시 모니터링을 사용한 후에는 다시 비활성화해야 한다.

#### MySQL의 종료 메시지
MySQL이 종료됄 때는 에러 로그 파일에 종료된 이유가 메시지로 기록된다.
- MySQL 서버를 정상 종료시켰다면 "Normal shutdown" 메시지가 출력된다.
- 세그먼테이션 폴트인 경우 아무런 종료 관련 메시지가 없거나 스택 트레이스와 같은 내용의 메시지가 출력된다.


### 제너럴 쿼리 로그 파일(제너럴 로그 파일, General log)
쿼리 로그를 활성화하면 쿼리 로그 파일에 기록되며, 시간 단위로 어떤 쿼리가 실행되었는지 기록된다. 제너럴 쿼리 로그는 쿼리 실행 중에 에러가 발생해도 일단 로그 파일에 저장한다.
- MySQL 서버에서 실행되는 전체 쿼리 목록을 조회할 수 있다.

### 슬로우 쿼리 로그
슬로우 쿼리 로그는 설정에 정의한 시간 이상의 시간이 소요된 쿼리가 모두 기록 된다. MySQL이 쿼리를 실행한 후 실제 소요된 시간을 기준으로 하므로 쿼리가 반드시 정상적으로 실행이 완료되어야 한다.
- 설정 파일에서 long_query_time 파라미터로 시간을 설정할 수 있다.
- 서비스에서 사용하고 있는 쿼리 중에서 어떤 쿼리가 문제인지 판단할 수 있다.

### 바이너리 로그와 릴레이 로그
바니어리 로그와 릴레이 로그는 복제의 구조에서 사용되는 로그이며, 바이너리 로그는 마스터 MySQL 서버에서 릴레이 로그는 슬레이브 MySQL 서버에서 사용된다. 하지만 바이너리 로그나 릴레이 로그나 파일의 내용이나 포맷은 동일하다.

바이너리 파일은 순수한 SELECT 문장과 같이 데이터의 구조나 내용을 변경하지 않는 쿼리는 기록되지 않는다. 그리고 이진 파일로 되어 있어 사람이 읽으려면 텍스트 형태로 변경해야 한다. 이는 MySQL에서 명령어로 제공하며, 특정 시간 범위나 특정 위치만을 지정하여 확인해볼 수도 있다.