# 베스트 프랙티스

### 16.7 MySQL 표준 설정

> MySQL 서버를 서비스에 맞게 변화시켜서 최적화하자

##### 왜?

- MySQL의 기본 확장 방식은 스케일업이 아닌 `스케일 아웃`
- 장비나 인스턴스의 개수가 많아져서 조정이 많다.
- 기존의 설정 파일이 다른 서비스에 최적화된 설정인지 모호하다.
- 서비스가 사용되는 동안 여러 가지 모니터링이나 상태 값 분석을 통해 확장하는 것이 최선이다.
- MySQL의 서버 설정에는 하드웨어 적으로 고려해야할 옵션이 4~5개, 복제 용도별로 고려해야할 옵션이 4~5개인데 초기에는 최적의 값을 선정하기 어렵다.
- **결론은 초기 설정 파일을 미리 준비하자**

##### 표준 설정의 예시

- 그림 옮기기 귀찮... 책보자
- 자세한 내용은 2장 참조.
- 성능상의 이슈가 우려되는 부분은 고정적으로 통일해서 일괄 대응하자.
- 하드웨어 성능에 영향을 끼치는 부분은 별도의 주석으로 표기한다.

---

### 16.8 복제를 사용하지 않는 MySQL 설정

- 복제를 사용하려면 `바이너리 로그 파일`이 활성화돼야 한다.
    * DB 변경(테이블 생성, 삭제등) 및 Table 변경(insert, update, delete..) 사항들이 기록하는 파일

- 하지만 바이너리 로그는 디스크 I/O의 비용이 크고, 내부적으로 락을 사용해서 테이블 잠금에도 영향을 끼친다.

- **결론은 복제를 사용하지 않으면 바이너리 로그를 비활성화하고 격리 수준을 `READ-COMMITTED`로 하자**

---

### 16.9 MySQL 복제 구축

> 서비스용으로 사용되는 데이터는 기본적으로 여러 가지 목적으로 복제를 구성해서 서비스에 적용하는 것이 일반적이다.

- `하나의 슬레이브가 둘 이상의 마스터를 가질 수 없다`만 주의하자


##### 1:M

- 그림은 역시 책이지

- 백업이나 통계, 배치 프로그램의 용도로 슬레이브 사용
- 슬레이브는 보통 읽기 전용
- 복제는 마스터에서 슬레이브로 비동기 전달 -> 데이터 변경 바로 직후는 마스터에서 SELECT 하자
- 슬레이브가 10대 이상이라면 1:M:M 가자

##### 1:M:M

- 마스터가 해야하는 바이너리 로그 전달을 슬레이브에게 넘긴다.
- 전달받은 슬레이브는 마스터의 역할을 하며 2차 복제를 한다.
- 통계나 배치, 백업 용도로 2차 복제로 한다.
- MySQL을 업그레이드하거나 장비교체 할 때도 사용된다.

##### 스케일아웃

- 최대한 읽기 작업을 슬레이브로 옮겨야 마스터가 쓰기 작업에만 집중할 수 있다.

##### 가용성

- 마스터에 문제가 생기면 슬레이브를 마스터로 승격시킨다
- 읽기모드를 해제하고 바이너리 로그를 활성화시킨다.
- `MMM` : 마스터가 죽으면 자동으로 슬레이브를 승격시켜주는 도구

##### 복제가 구축된 MySQL에서의 작업

- 마스터에서 병렬적으로 실행되는 SQL은 슬레이브에서 직렬화되어 순차적으로 처리된다.
- 그래서 시간이 오래걸리는 인덱스나 칼럼추가 등은 각각의 서버에서 별도로 실행하는 것이 좋다.
- 근데 슬레이브는 읽기전용이라며??? -> 서비스용으로 사용하고있는 슬레이브를 말하는건가
- 별도로 실행할때 명령이 슬레이브로 넘어가지 않게 주의하자

---

### 16.10 작성 표준

- 꿀팁인듯

##### 1. 조인 조건은 항상 ON 절에 기재

```java
queryFactory.selectFrom(academy)
                    .join(teacher).on(academy.id.eq(teacher.academyId))
                    .where(teacher.name.eq("JM"))
                    .fetch();
```

##### 2. 테이블 별칭(Alias) 사용 및 칼럼 명에 테이블 별칭 포함

```java
queryFactory.select(Projections.fields(AcademyTeacher.class,
                        academy.name.as("academyName"),
                        teacher.name.as("teacherName")
                    ))
                    .from(academy)
                    .join(teacher).on(academy.id.eq(teacher.academyId))
                    .where(teacher.name.eq("JM"))
                    .fetch();
```

##### 3. 서버 사이드 프리페어 스테이트먼트 사용

- DBMS에서 동일하거나 비슷한 데이터베이스 문을 높은 효율성으로 반복적으로 실행하기 위해 사용되는 기능

```sql
INSERT INTO products (name, price) VALUES (?, ?);
```

##### 4. FULL GROUP BY 사용

```sql
SELECT id, phone_num
FROM  user
GROUP BY id

SELECT id, phone_num
FROM  user
GROUP BY id, phone_num
```

##### 5. DELETE, UPDATE 쿼리에서 ORDER BY .. LIMIT.. 사용 자제

- 그러랍니다.

##### 6. 문자열 리터럴 표기는 홑따옴표만 사용

```sql
INSERT INTO old VALUES ('에이든', '30');
```

##### 7. 서브쿼리는 조인으로 변경

- MySQL 5.5버전까지 서브쿼리 최적화하는 기능이 상당히 부족하다. (이후 버전은 모르겠음)
- 조인의 최적화는 상당히 높은편이다.

##### 8. UNION [ALL] 은 사용 자제

- 내부적으로 임시테이블을 버퍼링한 다음, 결과를 반환한다.

##### 9. 스토어드 함수는 가능하면 `DETERMINSTIC`으로 정의

- 11장 보자

##### 10. 스토어드 프로그램에서는 예외 처리 코드를 작성

- 11장 두번 보자

##### 11. UPDATE, DELETE 쿼리와 적용 건수 체크

- COMMIT하기 전에 UPDATE, DELETE가 몇 건이 적용되었나 체크하자
- 13장 참조

##### 12. 숫자 값은 반드시 숫자 타입의 칼럼으로 정의

- 숫자 칼럼을 VARCHAR 하지 말자

---

### 16.11 하드웨어와 플랫폼 선정

- 솔직히 안읽었다. 읽고싶지 않다.

---

### 16.12 백업 및 모니터링

- 흠

---

### 16.13 스키마 검토

- 서비스를 오픈하거나 새로운 기능이 업그레이드 되었을때
- 대표적으로 사용되는 주요 칼럼이나 조인의 키 칼럼에 대해 스키마 검토를 진행하는 것도 좋다.

---

# 끗
