## 10.3.3 해시 파티션

- 해시 파티션은 Mysql에서 정의한 해시 함수에 의해 레코드가 저장될 파티션을 결정하는 방법
    - 파티션 표현식의 결과 값 % 파티션의 개수 = 저장될 파티션 위치

![사진 4](../images/사진4.jpeg)

- 해시 파티션 키는 정수를 반환하는 표현식만 사용될 수 있다.
- 파티션의 개수가 파티션을 할당하는 알고리즘과 연관되어 있기 때문에 파티션의 추가, 삭제 작업은 테이블 전체적으로 레코드를 재분배해야한다.

### 해시 파티션의 용도는?

- 레인지 , 리스트 파티션으로 데이터를 균등하게 나누기 어려울 때
- 테이블이 큰데 그 테이블의 모든 레코드가 비슷한 사용 빈도를 보일 때
    - ex) 회원 테이블
        - 회원 테이블은 회원의 지역이나 취미같은 정보가 사용 빈도에 미치는 영향이 거의 없다.
        - 테이블의 데이터가 특정 칼럼에 영향을 받지 않고 전체적으로 비슷한 사용빈도를 보인다.

## 분리와 병합

- 해시 파티션에서 가장 자주 나오는 이야기는 다음과 같다.
    - 파티션 키 값을 테이블의 파티션 개수로 나머지 연산을 한 결과에 의해 레코드가 저장될 파티션을 결정한다.
    - 따라서 분리와 병합에서도 이러한 메커니즘이 적용이 되기 때문에 분리 병합을 할 떄에도 해시 함수의 알고리즘이 변경되게 되고 전체적인 파티션이 영향을 받는다.
- 해시 파티션에서 파티션을 추가할 때의 모습

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fdb49a3c-cb9f-4c89-88cf-6b92fb98d53c/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fdb49a3c-cb9f-4c89-88cf-6b92fb98d53c/Untitled.png)

- 파티션 분할
    - 파티션을 분할하는 기능이 없음
- 파티션 병합
    - 2개 이상의 파티션을 하나로 합치는 기능은 없다.
    - 하지만 전체 파티션이 4개였던 것을 3개로 재구성은 할 수 있다.

```sql
ALTER TABLE employees COALESCE PARTITION 1;
```

- 뒤의 숫자 1은 줄이고자 하는 파티션의 개수 그러니까 4개에서 3개로 가면 1개를 줄이는 거니까 1

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8110314e-b3ed-495c-9fc3-d008aa4609ac/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8110314e-b3ed-495c-9fc3-d008aa4609ac/Untitled.png)

- 해시 파티션 주의사항
    - 특정 파티션만  DROP X
    - 파티션 추가 작업은 모든 데이터의 재배치 작업 필요
    - 때문에 해시 파티션에선 삭제나 병합등의 작업이 불필요하다.

## 10.3.4 키 파티션

- 해시 파티션과 사용법과 특성이 거의 같다.
- 차이점은 해시 파티션은 정수 값을 반환하는 표현식만 가능했는데, 키 파티션은 MD5() 함수를 이용해서 해시 값을 계산하기 때문에 대부분의 데이터 타입에 대해 파티션 키를 적용할 수 있다.
- 때문에 해시 파티션으로 파티셔닝이 어렵다면 고려해 볼만한 것이 키 파티션

```sql
PARTITION BY KEY()
PARTITIONS 2;
// 이렇게 프라이머리 키의 일부만 명시할 수도 있다. 
```

- 괄호 안에 아무 내용도 넣지 않으면 자동으로 프라이머리 키의 모든 칼럼이 파티션 키가 된다.
- 프라이머리 키가 없는 경우 유니크 키가 파티션 키로 사용된다.
- 유키크 키를 파티션 키로 지정할 때 유니크 키는 반드시 NOT NULL이어야 한다.
- 해시 파티션 보다 레코드를 더 균등하게 분할할 수 있어서 더 자주 사용된다.

## 10.3.5 리니어 해시 파티션/ 리니어 키 파티션

- 해시 파티션과 키 파티션에서 단점으로 있던 파티션 추가 및 통합에서 데이터를 모두 재분배 해야하는 약점을 보완한 파티션

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fd557394-ac55-4b0a-ac33-8b4335b8e402/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fd557394-ac55-4b0a-ac33-8b4335b8e402/Untitled.png)

- 레코드 분배를 위해 "Power of two" 알고리즘을 이용한단다. 이 알고리즘이 뭔지는 잘 모르겠다 솔직히..
- 그래서 해시 파티션이나 키 파티션으로 파티션된 테이블에 대해 새로운 파티션을 추가하거나 삭제해야하는 조건이 많다면 리니어 해시 / 키 파티션을 이용하면 좋을 것 같다.

### 10.3.6 서브 파티션

- 서브 파티션은 레인지 파티션 내에서 다시 지역별로 서브 파티션을 구성하는 것인데, Mysql 에서는 최대로 사용 가능한 파티션의 개수가 다른 DBMS보다 상당히 제한적이라서 서브 파티션으로 얻을 수 있는 이점을 별로 없다고 한다..

### 10.3.7 파티션 테이블 실행 계획

- 명령어를 직접 쳐보며 배워봅시다.

### 10.3.8 파티션 테이블 관련 벤치마킹

- INSERT 성능
    - 레인지 파티션이 일반테이블보다 35%정도 빨랐던 벤치마킹 결과가 있다. 대략 1200만 건의 레코드를   INSERT 하는 테스트였다. 이 성능은 인덱스나 데이터가 물리적인 메모리보다 훨씬 큰 상황에서 나타나는 성능과 비슷하다고 생각 할 수 있다.
- SELECT 성능
    - SELECT 성능은 별 차이가 없다..
